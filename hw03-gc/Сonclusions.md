### Задание №3
1. Добаиться OutOfMemory через медленное подтекание памяти
    
    Сборка:  
    `$mvn clean package`
    
    Запуск:  
    `$java -Xms512m -Xmx512m -XX:+UseG1GC -Xlog:gc=debug:file=./gc-%p-%t.log:tags,uptime,time,level:filecount=5,filesize=10m -cp hw03-gc/target/classes/ ru.otus.hw03.oom.OOMDemo`
     
1. Сравнение сборщиков мусора  
    Для сравнения были выбраны G1, как сборщик мусора по умолчанию в Java, 
    начиная с версии 9, Parallel Collector - сборщик заточенный на минимальное время сборки в режиме stop the world, 
    а так же, SerialGC - потенциально оптимальный сборщик для компактных инстансов с небольшим количеством ресурсов.  
    Тестирование проводилось с настройками памяти `-Xms1024m -Xmx1024m`  
    
    - Стандартные настройки GC в приложении не создающем долгосрочного мусора во время работы  
    
    Настройки GC      |Время работы GC   |Максимальная пауза |Время работы приложения
    ------------------|------------------|-------------------|------------------
    -XX:+UseG1GC      |91s, 82s, 67s     |266ms, 274ms, 419ms| 177s, 152s, 128s
    -XX:+UseParallelGC|42s, 43s, 48s     |137ms, 177ms, 197ms| 62s, 62s, 71s
    -XX:+UseSerialGC  |1s, 1s, 2s        |353ms, 375ms, 391ms| 34s, 34s, 34s  
    
    - Стандартные настройки GC в приложении с 'подтеканием памяти'  
    
    Настройки GC      |Время работы GC|Максимальная пауза |Время работы приложения
    ------------------|---------------|-------------------|---------------
    -XX:+UseG1GC      |27s, 27s, 31s  |134ms, 129ms, 127ms|51s, 50s, 55s
    -XX:+UseParallelGC|52s, 48s, 49s  |512ms, 310ms, 332ms|74s, 66s, 67s
    -XX:+UseSerialGC  |90s, 90s, 90s, |680ms, 662ms, 693ms, |107s, 107s, 106s,  
    
    - Попытка добиться максимального Latency в приложении с 'подтеканием памяти'  
    
    Настройки GC                              |Время работы GC   |Максимальная пауза |Время работы приложения
    ------------------------------------------|------------------|-------------------|-------
    -XX:+UseG1GC -XX:MaxGCPauseMillis=30      |26s, 30s, 26s     |177ms, 390ms, 93ms |51s, 63s, 50s
    -XX:+UseParallelGC -XX:MaxGCPauseMillis=30|57s, 59s, 60s     |732ms, 722ms, 668ms|76s, 78s, 78s
    -XX:+UseSerialGC -XX:MaxGCPauseMillis=30  |91s, 91s, 91s     |711ms, 718ms, 668ms|108s, 108s, 107s 
        
    - Попытка добиться максимального Throughput увеличением параметра `-XX:MaxGCPauseMillis` и уменьшение `-XX:GCTimeRatio` не дала заметных изменений
    
    
   Заключение:  
   Синтетические тесты показали, что в приложениях с минимальным колличеством долгосрочных объектов
   уверенно лидирует `SerialGC`. Если исключить "прогрев" сборщика, то паузы stop the world занимали до 2ms,
   что делает его лидером в показателе `Latency`. Общее время работы так же говорит об уверенно отрыве в 
   показателе `Throughput`.
   `ParallelGC` так же показывает уверенный результат в обоих показателях при работе в приложениях с минимальным
   количеством живых объектов. Так же, как и `SerialGC`, `ParallelGC` показывает очень хорошие результаты 
   stop the world после разогрева, останавливая приложение маесимум на 3ms. Тем не менее, `ParallelGC` заметно 
   проигрывает `SerialGC` как по `Latency`, так и по `Throughput`.  
   Совершенно иные показатели демонстрирует `G1`. Его эффективность гораздо заметнее в приложениях с большим количеством 
   живых объектов и мусора. Более того, он лучше предыдущих поддаётся настройке пауз приложения. Если не считать чисток 
   старых объектов, `G1` полностью вписывался в заданные 30ms, чего не скажешь двух жругих сборщиках.  
   
   Вывод: Для небольших сервисов, заточенных на работу в stateless режиме я бы выбрал `SerialGC`. В случае же больше 
   сложных приложений, обосенно с in-memory cache, я оставил бы сборщик по умолчанию `G1`. 