### Задание №3
1. Добаиться OutOfMemory через медленное подтекание памяти
    
    Сборка:  
    `$mvn clean package`
    
    Запуск:  
    `$java -Xms512m -Xmx512m -XX:+UseG1GC -Xlog:gc=debug:file=./gc-%p-%t.log:tags,uptime,time,level:filecount=5,filesize=10m -cp hw03-gc/target/classes/ ru.otus.hw03.oom.OOMDemo`
     
1. Сравнение сборщиков мусора  
    Для сравнения были выбраны сборщики мусора G1, как сборщик мусора по умолчанию в Java, 
    начиная с версии 9 и Parallel Collector, сборщик заточенный на минимальное время сборки в режиме stop the world.  
    Тестирование проводилось с настройками памяти `-Xms1024m -Xmx1024m`  
    
    - Стандартные настройки GC в приложении не создающем долгосрочного мусора во время работы  
    
    Настройки GC      |Время работы GC   |Максимальная пауза |Время работы приложения
    ------------------|------------------|-------------------|------------------
    -XX:+UseG1GC      |91s, 82s, 67s     |266ms, 274ms, 419ms| 177s, 152s, 128s
    -XX:+UseParallelGC|42s, 43s, 48s     |137ms, 177ms, 197ms|62s, 62s, 71s
    
    - Стандартные настройки GC в приложении с 'подтеканием памяти'  
    
    Настройки GC      |Время работы GC|Максимальная пауза |Время работы приложения
    ------------------|---------------|-------------------|---------------
    -XX:+UseG1GC      |27s, 27s, 31s  |134ms, 129ms, 127ms|51s, 50s, 55s
    -XX:+UseParallelGC|52s, 48s, 49s  |512ms, 310ms, 332ms|74s, 66s, 67s
    
    - Попытка добиться максимального Latency в приложении с 'подтеканием памяти'  
    
    Настройки GC                              |Время работы GC   |Максимальная пауза |Время работы приложения
    ------------------------------------------|------------------|-------------------|-------
    -XX:+UseG1GC -XX:MaxGCPauseMillis=30      |26s, 30s, 26s     |177ms, 390ms, 93ms |51s, 63s, 50s
    -XX:+UseParallelGC -XX:MaxGCPauseMillis=30|57s, 59s, 60s     |732ms, 722ms, 668ms|76s, 78s, 78s
        
    - Попытка добиться максимального Throughput увеличением параметра `-XX:MaxGCPauseMillis` и уменьшение `-XX:GCTimeRatio` не дала заметных изменений
    
    
   Заключение:  
   Исходя из синтетических тестов, удалось найти единственный случай, в котором `G1` проигрывает `ParallelGC`, 
   когда в приложении преимущественно создаются объекты, которые сразу же и умерают. 
   В осталных случаях `G1` уверенно выигрывает как по Latency, так и по Throughput.